use Kind.Checker as Checker
use Kind.Term as Term
use Kind.Error as Error

// Functions that succedes if a term checks agaisnt a type.
Checker/check (term: Kind.Term) (type: Kind.Term): Kind.Checker Unit
Checker/check (Term/lam orig name body) type =
  Checker/bind Checker/get_subst (subst =>
    let fun = (Term/if_all type
      (t_orig => t_name => t_type => t_body => (orig: U60) => (name: U60) => (body: Kind.Term -> Kind.Term) =>
        do Kind.Checker {
          ask dep = Checker/get_depth
          ask chk = Checker/extended (Checker/check (body (Term/var orig name dep)) (t_body (Term/var t_orig t_name dep))) name t_type []
          return Unit.new
        }
      )
      ((orig: U60) => (name: U60) => (body: Kind.Term -> Kind.Term) =>
        Checker/bind Checker/get_context (ctx => Checker/fail (Error/cant_infer_lambda ctx orig)))
    ) :: U60 -> U60 -> (Kind.Term -> Kind.Term) -> Kind.Checker Unit
    fun orig name body
  )

Checker/check (Term/let orig name expr body) type =
  do Kind.Checker {
    ask dep      = Checker/get_depth
    ask expr_typ = Checker/infer expr
    ask body_chk = Checker/extended (Checker/check (body (Term/var orig name dep)) type) name expr_typ [(Term/eval expr)]
    return Unit.new
  }

Checker/check (Term/hlp orig) type =
  do Kind.Checker {
    ask ctx = Checker/get_context
    Checker/error (Error/inspection ctx orig type) Unit.new
    // TODO: Check why it returns a type in the original version
    return Unit.new
  }

Checker/check (Term/var orig name idx) type =
  do Kind.Checker {
    ask rhs = Checker/get_right_hand_side
    if rhs {
      Checker/compare rhs (Term/var orig name idx) type
    } else {
      Checker/extend name type List.nil
    }
  }

Checker/check (Term/hol orig numb) type =
  Checker/pure Unit.new

Checker/check term type =
  do Kind.Checker {
    ask rhs = Checker/get_right_hand_side
    (Checker/compare rhs term type)
  }

Checker/compare (rhs: Bool) (term: Kind.Term) (type: Kind.Term): Kind.Checker Unit
Checker/compare rhs term type =
  Term/get_origin term (orig => term =>
    Checker/bind (Checker/infer term) (term_typ =>
      let fun =
        ((if rhs {
          (term_typ: Kind.Term) => (type: Kind.Term) =>
            Checker/new_equation orig type term_typ
        } else {
          (term_typ: Kind.Term) => (type: Kind.Term) =>
            do Kind.Checker {
              ask is_equal = Checker/equal (Term/eval term_typ) (Term/eval type)
              if is_equal {
                Checker/pure Unit.new
              } else {
                do Kind.Checker {
                  ask ctx =  Checker/get_context
                  (Checker/fail (Error/impossible_case ctx orig type term_typ))
                }
              }
            }
        }) :: Kind.Term -> Kind.Term -> Kind.Checker Unit)
      fun term_typ type))